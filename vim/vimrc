call plug#begin('~/.vim/plugged')

" code completion
Plug 'SirVer/ultisnips'
Plug 'Valloric/YouCompleteMe', { 'do': './install.py --clang-completer --gocode-completer --tern-completer --racer-completer' }
Plug 'ervandew/supertab'
Plug 'honza/vim-snippets'
Plug 'jiangmiao/auto-pairs'

" language support
Plug 'critiqjo/lldb.nvim'
Plug 'derekwyatt/vim-scala'
Plug 'elzr/vim-json'
Plug 'fatih/vim-go'
Plug 'hdima/python-syntax'
Plug 'nsf/gocode', { 'rtp': 'nvim', 'do': '~/.vim/plugged/gocode/nvim/symlink.sh' }

" git
Plug 'Xuyuanp/nerdtree-git-plugin', { 'on': 'NERDTreeToggle' }
Plug 'airblade/vim-gitgutter', { 'on': 'GitGutterToggle' }
Plug 'tpope/vim-fugitive'

" gui related
Plug 'baskerville/bubblegum'
Plug 'junegunn/seoul256.vim'
Plug 'luochen1990/rainbow'
Plug 'mhartington/oceanic-next'
Plug 'morhetz/gruvbox'

" misc
Plug 'Chiel92/vim-autoformat'
Plug 'Shougo/unite.vim', { 'on': 'Unite' }
Plug 'Yggdroot/indentLine'
Plug 'easymotion/vim-easymotion'
Plug 'jeetsukumaran/vim-buffergator', { 'on': ['BuffergatorMruCyclePrev', 'BuffergatorMruCycleNext', 'BuffergatorToggle'] }
Plug 'majutsushi/tagbar', { 'on': ['TagbarToggle', 'TagbarClose'] }
Plug 'mhinz/vim-grepper'
Plug 'scrooloose/nerdcommenter'
Plug 'scrooloose/nerdtree', { 'on': ['NERDTreeToggle', 'NERDTreeClose'] }
Plug 'szw/vim-tags', { 'on': 'TagsGenerate' }
Plug 'terryma/vim-expand-region'
Plug 'tpope/vim-surround'
Plug 'tsukkee/unite-tag', { 'on': 'Unite' }
Plug 'vim-utils/vim-man', { 'on': ['Man' , 'Vman'] }

call plug#end()


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set history=10000

filetype plugin indent on

syntax enable

set autoread

set autowriteall

let mapleader=","

nnoremap <leader>w :w<cr>
nnoremap <leader>q :q<cr>

set encoding=utf8
set fileformats=unix,dos,mac

set clipboard=unnamed,unnamedplus

set expandtab

set smarttab

set shiftwidth=2
set tabstop=2

set nowrap
set nolinebreak
set textwidth=80

set autoindent
set smartindent

autocmd filetype markdown setlocal wrap linebreak
autocmd bufnewfile,bufread * setlocal formatoptions-=cro


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Vim user interface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set scrolloff=3
set sidescrolloff=6
set sidescroll=1

" Turn on the WiLd menu
set wildmenu

" set wildignore=*.o,*.pyc

set ruler

set cmdheight=2

set hidden

set backspace=eol,start,indent
set whichwrap+=<,>,h,l

" set mouse=a

set ignorecase
set smartcase

set hlsearch
set incsearch

set lazyredraw

set magic

set showmatch

" No annoying sound on errors
set noerrorbells
set novisualbell
set t_vb=
set tm=500

set foldmethod=indent
set foldnestmax=10
set nofoldenable
set foldlevel=1
set foldcolumn=1

set number
nmap <leader>nn :set number!<cr>

" set completeopt=menu,preview,longest
set completeopt-=preview

set cursorline

if v:version >= 703
  set colorcolumn=80
else
  autocmd BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)
endif

set linespace=3


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => colors, gui and fonts
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""" bubblegum
" colorscheme bubblegum-256-dark


"""""""""" seoul256 dark
" Range:   233 (darkest) ~ 239 (lightest)
" Default: 237
" set background=dark
" let g:seoul256_background=235
" colorscheme seoul256


"""""""""" seoul256 light
" Range:   252 (darkest) ~ 256 (lightest)
" Default: 253
" set background=light
" let g:seoul256_background=252
" colorscheme seoul256-light


"""""""""" oceanic-next
" set background=dark
" colorscheme OceanicNext


"""""""""" gruvbox dark
set background=dark
let g:gruvbox_contrast_dark='soft'

"""""""""" gruvbox light
" set background=light
" let g:gruvbox_contrast_light='soft'

let g:gruvbox_bold=0
let g:gruvbox_italic=1
let g:gruvbox_invert_signs=0
let g:gruvbox_invert_selection=1
let g:gruvbox_improved_strings=0
let g:gruvbox_improved_warnings=1

if v:version >= 703
  colorscheme gruvbox
else
  colorscheme desert
endif

if has('gui_running')
  set guioptions-=l
  set guioptions-=L
  set guioptions-=r
  set guioptions-=R
  set guioptions-=m
  set guioptions-=T
  set guifont=Source\ Code\ Pro\ Medium\ 13
  set guifontwide=Source\ Han\ Sans\ CN\ 12

  set lines=38
  set columns=220
endif

" map<f11> :call system("wmctrl -ir " . v:windowid . " -b toggle,fullscreen")<cr>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => files, backups and undo
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set noswapfile

set undolevels=5000
if v:version >= 703
  set undodir=~/.vim/vim_undo_files
  set undofile
endif

set updatecount=10


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => moving around, tabs, windows and buffers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
func! ToggleMovement(firstOp, thenOp)
  let pos = getpos('.')
  execute "normal! " . a:firstOp
  if pos == getpos('.')
    execute "normal! " . a:thenOp
  endif
endfunc

" the original carat 0 swap
nnoremap <silent>0 :call ToggleMovement('^', '0')<cr>

" how about ; and ,
nnoremap <silent>; :call ToggleMovement(';', ',')<cr>
nnoremap <silent>, :call ToggleMovement(',', ';')<cr>

" how about h and l
nnoremap <silent>H :call ToggleMovement('H', 'L')<cr>
nnoremap <silent>L :call ToggleMovement('L', 'H')<cr>

" how about g and gg
nnoremap <silent>G :call ToggleMovement('G', 'gg')<cr>
nnoremap <silent>gg :call ToggleMovement('gg', 'G')<cr>

nnoremap <silent><bs> :nohlsearch<cr>

nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

map <leader>tn :tabnew<cr>
map <leader>to :tabonly<cr>
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove
map <leader>t<leader> :tabnext
map <leader>t? :map <leader>t <cr>

map <leader>1 :tabnext1<cr>
map <leader>2 :tabnext2<cr>
map <leader>3 :tabnext3<cr>
map <leader>4 :tabnext4<cr>
map <leader>5 :tabnext5<cr>
map <leader>6 :tabnext6<cr>
map <leader>7 :tabnext7<cr>
map <leader>8 :tabnext8<cr>
map <leader>9 :tabnext9<cr>

map <leader>te :tabedit <c-r>=expand("%:p:h")<cr>/

set switchbuf=useopen,usetab,newtab

autocmd bufreadpost *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif

set viminfo=h,'500,<10000,s1000,/1000,:1000


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => status line
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" statusline setup
set statusline=%#identifier#
set statusline+=[%f]    " tail of the filename
set statusline+=%*

" display a warning if fileformat isnt unix
set statusline+=%#warningmsg#
set statusline+=%{&ff!='unix'?'['.&ff.']':''}
set statusline+=%*

set statusline+=%h      " help file flag
set statusline+=%y      " filetype

" read only flag
set statusline+=%#identifier#
set statusline+=%r
set statusline+=%*

" modified flag
set statusline+=%#warningmsg#
set statusline+=%m
set statusline+=%*

if v:version >= 703
  set statusline+=%{fugitive#statusline()}
endif

" display a warning if &et is wrong, or we have mixed-indenting
set statusline+=%#error#
set statusline+=%{StatuslineTabWarning()}
set statusline+=%*

set statusline+=%{StatuslineTrailingSpaceWarning()}
" set statusline+=%{StatuslineLongLineWarning()}

" display a warning if &paste or &spell is set
set statusline+=%#error#
set statusline+=%{&paste?'[paste]':''}
set statusline+=%{&spell?'[spell]':''}
set statusline+=%{&number?'':'[nonumber]'}
set statusline+=%*

set statusline+=%=      " left/right separator
" current highlight
" set statusline+=%{StatuslineCurrentHighlight()}
set statusline+=\ %c,   " cursor column
set statusline+=%l/%L   " cursor line/total lines
set statusline+=\ %P    " percent through file

" always show the status line
set laststatus=2

" recalculate the tab warning flag when idle and after writing
autocmd cursorhold,bufwritepost * unlet! b:statusline_tab_warning

" return '[&et]' if &et is set wrong
" return '[mixed-indenting]' if spaces and tabs are used to indent
" return an empty string if everything is fine
func! StatuslineTabWarning()
  if !exists("b:statusline_tab_warning")
    let b:statusline_tab_warning=''

    if !&modifiable
      return b:statusline_tab_warning
    endif

    let tabs=search('^\t', 'nw') != 0

    "find spaces that arent used as alignment in the first indent column
    let spaces=search('^ \{' . &ts . ',}[^\t]', 'nw') != 0

    if tabs && spaces
      let b:statusline_tab_warning='[mixed-indenting]'
    elseif (spaces && !&et) || (tabs && &et)
      let b:statusline_tab_warning='[&et]'
    endif
  endif
  return b:statusline_tab_warning
endfunc

" return '[\s]' if trailing white space is detected
" return '' otherwise
func! StatuslineTrailingSpaceWarning()
  if !exists("b:statusline_trailing_space_warning")

    if !&modifiable
      let b:statusline_trailing_space_warning=''
      return b:statusline_trailing_space_warning
    endif

    if search('\s\+$', 'nw') != 0
      let b:statusline_trailing_space_warning='[\s]'
    else
      let b:statusline_trailing_space_warning=''
    endif
  endif
  return b:statusline_trailing_space_warning
endfunc

" return a warning for "long lines" where "long" is either &textwidth or 80
" (if no &textwidth is set)
"
" return '' if no long lines
"
" return '[#x,my,$z] if long lines are found,
" were x is the number of long lines,
" y is the median length of the long lines
" and z is the length of the longest line
func! StatuslineLongLineWarning()
  if !exists("b:statusline_long_line_warning")

    if !&modifiable
      let b:statusline_long_line_warning=''
      return b:statusline_long_line_warning
    endif

    let long_line_lens=s:LongLines()

    if len(long_line_lens) > 0
      let b:statusline_long_line_warning="[" .
            \ '#' . len(long_line_lens) . "," .
            \ 'm' . s:Median(long_line_lens) . "," .
            \ '$' . max(long_line_lens) . "]"
    else
      let b:statusline_long_line_warning=""
    endif
  endif
  return b:statusline_long_line_warning
endfunc

" return a list containing the lengths of the long lines in this buffer
func! s:LongLines()
  let threshold=(&tw ? &tw : 80)
  let spaces=repeat(" ", &ts)
  let line_lens=map(getline(1,'$'), 'len(substitute(v:val, "\\t", spaces, "g"))')
  return filter(line_lens, 'v:val > threshold')
endfunc

" find the median of the given array of numbers
func! s:Median(nums)
  let nums=sort(a:nums)
  let l=len(nums)

  if l % 2==1
    let i=(l-1) / 2
    return nums[i]
  else
    return (nums[l/2] + nums[(l/2)-1]) / 2
  endif
endfunc

" return the syntax highlight group under the cursor ''
func! StatuslineCurrentHighlight()
  let name=synIDattr(synID(line('.'),col('.'),1),'name')
  if name==''
    return ''
  else
    return '[' . name . ']'
  endif
endfunc


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <leader>pp :setlocal paste!<cr>

func! TrimWhitespace()
  let l:winview=winsaveview()
  %s/\s\+$//e
  call winrestview(l:winview)
endfunc

autocmd bufwrite * :call TrimWhitespace()


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => spell checking
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nmap <leader>ss :setlocal spell!<cr>

nmap <leader>sn :echo 'Next misspelled word' <bar> ]s<cr>
nmap <leader>sp [s
nmap <leader>sa zg
nmap <leader>sg z=
nmap <leader>s? :map <leader>s<cr>

autocmd filetype svn, *commit* setlocal spell


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => plugins
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""" YouCompleteMe
let g:ycm_filetype_blacklist = {
      \ 'tagbar' : 1,
      \ 'qf' : 1,
      \ 'notes' : 1,
      \ 'markdown' : 1,
      \ 'unite' : 1,
      \ 'text' : 1,
      \ 'vimwiki' : 1,
      \ 'pandoc' : 1,
      \ 'infolog' : 1,
      \ 'mail' : 1,
      \ 'help' : 1
      \}

let g:ycm_error_symbol='✖'
let g:ycm_warning_symbol='⚑'
let g:ycm_always_populate_location_list=1
let g:ycm_complete_in_comments=0
let g:ycm_complete_in_strings=0
let g:ycm_collect_identifiers_from_tags_files=1
let g:ycm_server_python_interpreter='/usr/bin/python'
let g:ycm_seed_identifiers_with_syntax=1
let g:ycm_autoclose_preview_window_after_completion=1
let g:ycm_autoclose_preview_window_after_insertion=1
let g:ycm_key_list_select_completion=['<c-j>', '<c-n>', '<down>']
let g:ycm_key_list_previous_completion=['<c-k>', '<c-p>', '<up>']
let g:ycm_global_ycm_extra_conf='~/.vim/ycm_extra_conf.py'
let g:ycm_extra_conf_globlist=['~/.vim/*']
let g:ycm_confirm_extra_conf=1
let g:ycm_cache_omnifunc=0
let g:ycm_use_ultisnips_completer=1
let g:ycm_goto_buffer_command='vertical-split'
let g:ycm_disable_for_files_larger_than_kb=1024

nnoremap <f5> :YcmForceCompileAndDiagnostics<cr>
nnoremap <leader>ji :YcmCompleter GoToInclude<cr>
nnoremap <leader>jd :YcmCompleter GoToDeclaration<cr>
nnoremap <leader>j :YcmCompleter GoTo<cr>
nnoremap <leader>gt :YcmCompleter GetType<cr>
nnoremap <leader>gp :YcmCompleter GetParent<cr>
nnoremap <leader>gd :YcmCompleter GetDoc<cr>

nnoremap <leader>g? :nnoremap <leader>g<cr>
nnoremap <leader>j? :nnoremap <leader>j<cr>

nnoremap <leader>mm :exe '!c++filt '.expand('<cword>')<cr>


"""""""""" UltiSnips
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"


"""""""""" supertab
let g:SuperTabDefaultCompletionType='<c-n>'
let g:SuperTabCrMapping= 0


"""""""""" tagbar
let g:tagbar_compact=1
let g:tagbar_width=32

let g:tagbar_type_c={
      \ 'kinds': [
      \ 'd:macros:1:0',
      \ 'p:prototypes:1:0',
      \ 'g:enums',
      \ 'e:enumerators:0:0',
      \ 't:typedefs:0:0',
      \ 'n:namespaces',
      \ 'c:classes',
      \ 's:structs',
      \ 'u:unions',
      \ 'f:functions',
      \ 'm:members:0:0',
      \ 'v:variables:0:0',
      \ 'x:external:0:0',
      \ 'l:local:0:0'
      \ ]
      \ }

let g:tagbar_type_cpp={
      \ 'kinds': [
      \ 'd:macros:1:0',
      \ 'p:prototypes:1:0',
      \ 'g:enums',
      \ 'e:enumerators:0:0',
      \ 't:typedefs:0:0',
      \ 'n:namespaces',
      \ 'c:classes',
      \ 's:structs',
      \ 'u:unions',
      \ 'f:functions',
      \ 'm:members:0:0',
      \ 'v:variables:0:0',
      \ 'x:external:0:0',
      \ 'l:local:0:0'
      \ ]
      \ }

let g:tagbar_type_scala={
      \ 'ctagstype': 'scala',
      \ 'sro': '.',
      \ 'kinds': [
      \ 'p:packages',
      \ 'T:types:1',
      \ 't:traits',
      \ 'o:objects',
      \ 'O:case objects',
      \ 'c:classes',
      \ 'C:case classes',
      \ 'm:methods',
      \ 'V:values:1',
      \ 'v:variables:1'
      \ ]
      \ }

let g:tagbar_type_rust={
      \ 'ctagstype': 'rust',
      \ 'kinds': [
      \ 'T:types,type definitions',
      \ 'f:functions,function definitions',
      \ 'g:enum,enumeration names',
      \ 's:structure names',
      \ 'm:modules,module names',
      \ 'c:consts,static constants',
      \ 't:traits,traits',
      \ 'i:impls,trait implementations',
      \ ]
      \ }

let g:tagbar_type_go={
      \ 'ctagstype': 'go',
      \ 'kinds': [
      \ 'p:package',
      \ 'i:imports:1',
      \ 'c:constants',
      \ 'v:variables',
      \ 't:types',
      \ 'n:interfaces',
      \ 'w:fields',
      \ 'e:embedded',
      \ 'm:methods',
      \ 'r:constructor',
      \ 'f:functions'
      \ ],
      \ 'sro': '.',
      \ 'kind2scope': {
      \ 't': 'ctype',
      \ 'n': 'ntype'
      \ },
      \ 'scope2kind': {
      \ 'ctype': 't',
      \ 'ntype': 'n'
      \ },
      \ 'ctagsbin': 'gotags',
      \ 'ctagsargs': '-sort -silent'
      \ }

map <f3> :TagbarToggle<cr>

if v:version >= 703
  autocmd quitpre * TagbarClose
endif
" autocmd vimenter * nested :call tagbar#autoopen(1)
" autocmd filetype * nested :call tagbar#autoopen(0)
" autocmd bufenter * nested :call tagbar#autoopen(0)


"""""""""" nerdcommenter
let g:NERDSpaceDelims=1

map <leader>c? :map <leader>c<cr>


"""""""""" nerdtree
let g:NERDTreeMinimalUI=1
let g:NERDTreeWinSize=25
let g:NERDTreeAutoDeleteBuffer=1
let NERDTreeShowHidden=1

map <f2> :NERDTreeToggle<cr>
" autocmd vimenter * NERDTreeToggle
if v:version >= 703
  autocmd quitpre * NERDTreeClose
endif

" NERDTress File highlighting
func! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
  exec 'autocmd filetype nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
  exec 'autocmd filetype nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
endfunc


"""""""""" python syntax
let python_highlight_all=1


"""""""""" vim-autoformat
func! Format()
  let l:winview=winsaveview()
  Autoformat
  call winrestview(l:winview)
endfunc

map <leader>af :call Format()<cr>

let g:formatdef_google_clang_format='"clang-format -style=Google"'
let g:formatters_cpp=['google_clang_format']
let g:formatters_c=['google_clang_format']
let g:formatters_h=['google_clang_format']

let g:formatdef_yapf_format='"yapf --style=google"'
let g:formatters_python=['yapf_format']


"""""""""" vim-easymotion
map <leader><leader>l <Plug>(easymotion-lineforward)
map <leader><leader>j <Plug>(easymotion-j)
map <leader><leader>k <Plug>(easymotion-k)
map <leader><leader>h <Plug>(easymotion-linebackward)
map <leader><leader>. <Plug>(easymotion-repeat)

" keep cursor column when JK motion
let g:EasyMotion_startofline=0

let g:EasyMotion_smartcase=1


"""""""""" buffergator
" Use the right side of the screen
let g:buffergator_viewport_split_policy='R'

" Disable default keys
let g:buffergator_suppress_keymaps=1

let g:buffergator_autoexpand_on_split=0

" Go to the previous buffer open
nmap <leader>jj :BuffergatorMruCyclePrev<cr>

" Go to the next buffer open
nmap <leader>kk :BuffergatorMruCycleNext<cr>

" Toggle the entire list of buffers open
nmap <f1> :BuffergatorToggle<cr>

nmap <leader>en :enew<cr>
nmap <leader>bq :bp <BAR> bd #<cr>


"""""""""" vim-tags
set tags=./tags
let g:vim_tags_ignore_files=['.gitignore', '.svnignore', '.cvsignore']
let g:vim_tags_directories=['CMakeLists.txt', 'Makefile']
let g:vim_tags_use_language_field=0
let g:vim_tags_project_tags_command='{CTAGS} -R --c-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+iaSl --extra=+q {OPTIONS} {DIRECTORY} 2>/dev/null'
nmap <leader>tg :TagsGenerate!<cr>


"""""""""" vim-json
let g:vim_json_syntax_conceal=0


"""""""""" vim ack
nnoremap <leader>a :Ack


"""""""""" vim-gitgutter
let g:gitgutter_max_signs=5000
let g:gitgutter_enabled=0
let g:gitgutter_map_keys=0

map <leader>vg :GitGutterToggle<cr>


"""""""""" rainbow
" if has('gui_running')
" let g:rainbow_active=1
" let g:rainbow_conf = {
" \ 'guifgs': ['firebrick', 'brown1', 'gold3', 'purple4', 'blue', 'green'],
" \ }
" \ 'ctermfgs': ['red', 'bisque4']
" endif


"""""""""" indentLine
" ¦, ┆, or │
let g:indentLine_char='┊'
let g:indentLine_concealcursor=''
let g:indentLine_conceallevel=2
